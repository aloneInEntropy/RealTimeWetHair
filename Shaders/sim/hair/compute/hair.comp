/* 
! Storage Format
* GLM stores quaternions as xyzw, similarly to vec4s. For this reason, the values are in the same coordinates in GLM and GLSL, 
* so the only change necessary in GLSL is putting the scalar part at the end of the "quaternion" instead of the begninning.

! Offsets and strand maps
* For each strand, the offset between a vertex `i` and the rod that begins from it `j` widens by 1.
* So the appropriate rod can be found by simply subtracting the current strand index from the vertex index.
* e.g., strand 0 = v - 0, q - 0; strand 1 = v - 50, q - 49, strand 2 = v - 100, q - 98; etc.
* Similarly, Darboux vectors would subtract from rod index, e.g., q - 0, d - 0; q - 49, d - 48; etc.
* In short: 
*      - i = i
*      - j = i - vertexStrandMap[i]
*      - d = j - rodStrandMap[j]

! Transformations
* All hairs are assumed to be attached to a single head with a given transformation. This transformation is given as a uniform variable.
*/


#version 460 core

// layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec4 x;  // particle position
    vec4 v;  // particle velocity
    float w; // particle inverse mass
    int t;   // particle type. one of HAIR, SOLID, or FLUID
    int pd1, pd2;
};

struct Rod {
    vec4 q;  // rod orientation
    vec4 v;  // rod angular velocity
    float w; // rod inverse mass
    int pd1, pd2, pd3;
};

struct HairStrand {
    vec4 root;
    int nVertices;
    int startVertexIdx;
    int endVertexIdx;
    int nRods;
    int startRodIdx;
    int endRodIdx;
    float l0;
    int pd;
};

const int APPLY_EXTERNAL_FORCES = 0;
const int PREDICT = 1;
const int RESOLVE_COLLISIONS = 2; // any rigid body/fluid coupling here
const int STRETCH_SHEAR_CONSTRAINT = 3;
const int BEND_TWIST_CONSTRAINT = 4;
const int UPDATE_VELOCITIES = 5;

layout(std430, binding = 0) buffer Particles {
    Particle particles[];
};

layout(std430, binding = 1) buffer Rods {
    Rod rods[];
};

layout(std430, binding = 2) readonly buffer HairStrands {
    HairStrand hairStrands[];
};

layout(std430, binding = 3) buffer PredictedPositions {
    vec4 ps[];
};

layout(std430, binding = 4) buffer PredictedOrientations {
    vec4 us[];
};

layout(std430, binding = 5) readonly buffer RestDarbouxVectors {
    vec4 d0s[];
};

layout(std430, binding = 6) readonly buffer VertexToStrandMap {
    int vertexStrandMap[];
};

layout(std430, binding = 7) readonly buffer RodToStrandMap {
    int rodStrandMap[];
};

layout(location = 0) uniform int stage;      // the stage for the simulation
layout(location = 1) uniform float dt;       // delta time
layout(location = 2) uniform float gravity;  // gravity
layout(location = 3) uniform float l_drag;   // linear velocity drag
layout(location = 4) uniform float a_drag;   // angular velocity drag
layout(location = 5) uniform vec4 torque;    // rod torsion
layout(location = 6) uniform vec4 up;        // up vector
layout(location = 7) uniform mat3 inertia;   // inertia tensor matrix
layout(location = 8) uniform mat4 headTrans;     // transformation matrix of the head all roots are attached to
layout(location = 9) uniform int rbgs = -1;  // red (0) or black (1) ordering. if -1, ignore.
layout(location = 10) uniform float ss_SOR;  // SOR value for stretch and shear constraint
layout(location = 11) uniform float ss_k;    // stiffness for stretch and shear constraint
layout(location = 12) uniform float bt_SOR;  // SOR value for stretch and shear constraint
layout(location = 13) uniform float bt_k;    // stiffness for stretch and shear constraint
layout(location = 14) uniform float headRad;    // stiffness for stretch and shear constraint

mat3 toMat3(vec4 q);
vec3 Im(vec4 q);
vec3 darboux(int j); // todo: replace with in-place calculation to minimize branching
float darbouxSign(int i); // todo: replace with in-place calculation to minimize branching
float sqLen(vec3 p);
vec4 qmul(vec4 qa, vec4 qb);
vec4 qnorm(vec4 q);
vec4 conjugate(vec4 q);
int toJ(int i) { return i - vertexStrandMap[i]; }
int toDarboux(int j) { return j - rodStrandMap[j]; }


// Cast a quaternion `q` to a 3x3 matrix. Taken from GLM's implementation
mat3 toMat3(vec4 q) {
    mat3 m = mat3(1);
    float x = q.x;
    float y = q.y;
    float z = q.z;
    float w = q.w;

    m[0][0] = 1 - 2 * (y*y + z*z);
    m[0][1] = 2 * (x*y + z*w);
    m[0][2] = 2 * (x*z - w*y);
    m[1][0] = 2 * (x*y - z*w);
    m[1][1] = 1 - 2 * (x*x + z*z);
    m[1][2] = 2 * (y*z + x*w);
    m[2][0] = 2 * (x*z + y*w);
    m[2][1] = 2 * (y*z - x*w);
    m[2][2] = 1 - 2 * (x*x + y*y);
    
    return m;
}

// Create the Darboux vector from two adjacent quaternions `j` and `j + 1`. Uses predicted rotations
vec3 darboux(int j) {
    return Im(qmul(conjugate(us[j]), us[j + 1]));
}

// Compute the discrete Darboux sign factor
float darbouxSign(int j) {
    int d = toDarboux(j);
    float pos = sqLen(darboux(j) + d0s[d].xyz);
    float neg = sqLen(darboux(j) - d0s[d].xyz);
    if (neg <= pos) return 1;
    return -1;
}

// Compute the squared length of `p`
float sqLen(vec3 p) {
    return dot(p, p);
}

// Quaternion multiplication
vec4 qmul(vec4 p, vec4 q) {
    vec4 qo;
    qo.w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
    qo.x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
    qo.y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
    qo.z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
    return qo;
}

// Normalize a quaternion
vec4 qnorm(vec4 q) {
    return normalize(q);
}

// Extract the imaginary (vector) component of a quaternion
vec3 Im(vec4 q) {
    return q.xyz;
    // return q.yzw;
}

// Compute the conjugate of a quaternion
vec4 conjugate(vec4 q) {
    vec4 qq = vec4(0);
    qq.w = q.w;
    qq.xyz = -q.xyz;
    return qq;
}

// Get the root vertex of the strand containing vertex `i`
int getRootVertex(int i) { return hairStrands[vertexStrandMap[i]].startVertexIdx; }
int getRootVertex(uint i) { return getRootVertex(int(i)); }

// Get the tail vertex of the strand containing vertex `i`
int getTailVertex(int i) { return hairStrands[vertexStrandMap[i]].endVertexIdx; }
int getTailVertex(uint i) { return getTailVertex(int(i)); }

// Get the root rod of the strand containing rod `j`
int getRootRod(int j) { return hairStrands[rodStrandMap[j]].startRodIdx; }
int getRootRod(uint j) { return getRootRod(int(j)); }

// Get the tail rod of the strand containing rod `j`
int getTailRod(int j) { return hairStrands[rodStrandMap[j]].endRodIdx; }
int getTailRod(uint j) { return getTailRod(int(j)); }

void resolveCollisions(uint i) {
    if (ps[i].y < 0) {
        ps[i] = particles[i].x;
        ps[i].y = 0;
    }

    /* Project particles outside head */
    if (i == getRootVertex(i)) return;
    if (sqLen(vec3(ps[i] - headTrans[3])) < headRad * headRad) {
        vec3 dirToSurface = normalize(vec3(ps[i] - headTrans[3]));
        float distToSurface = length(ps[i].xyz - (headTrans[3].xyz + dirToSurface*headRad));
        ps[i] += vec4(dirToSurface * distToSurface, 0) * 10 * dt;
    }
}

// apply gravity and torque to the strand
void applyExternalForces(uint id) {
    int i = int(id);

    // gravity
    if (i != getRootVertex(i)) {
        particles[i].v += -up * gravity * dt;
    }

    // torque
    if (i == getTailVertex(i)) return;
    int j = toJ(i);
    rods[j].v += vec4(inverse(inertia) * (torque.xyz - cross(rods[j].v.xyz, inertia * rods[j].v.xyz)) * dt, 0);
}

// [KS16], Eq. 37
// Solve the stretch and shear constraint for vertices `i` and `i + 1` and quaternion `j`
void stretchAndShearConstraint(uint i) {
    if (i == getTailVertex(i)) return;

    int j = toJ(int(i));

    float l = hairStrands[vertexStrandMap[i]].l0;
    float w_q = rods[j].w;
    float w_v1 = particles[i].w;
    float w_v2 = particles[i + 1].w;

    vec3 e3 = up.xyz;
    vec3 d3 = toMat3(us[j]) * e3;
    vec3 C = ((vec3(ps[i + 1]) - vec3(ps[i])) / l) - d3;
    C *= l / (w_v1 + w_v2 + (w_q * 4 * l * l));
    vec3 disp_p1 = w_v1 * C * ss_k;
    vec3 disp_p2 = -w_v2 * C * ss_k;
    ps[i] += vec4(disp_p1, 0);
    ps[i + 1] += vec4(disp_p2, 0);

    vec4 e3b = qmul(us[j], conjugate(vec4(e3, 0)));
    vec4 disp_q = w_q * l * qmul(vec4(C * bt_k, 0), e3b);
    us[j] += disp_q;
    us[j] = qnorm(us[j]);
}

// [KS16], Eq. 40
// Solve the bend and twist constraint for rods `j` and `j + 1`
void bendAndTwistConstraint(uint i) {
    if (i == getTailVertex(i)) return;
    if (i == getTailVertex(i) - 1) return;
    int j = toJ(int(i));
    if (j == getTailRod(j)) return;

    int d = toDarboux(j);

    float w_q = rods[j].w;
    float w_u = rods[j + 1].w;
    float denom = w_q + w_u;
    vec3 omega = darboux(j);
    vec3 omega0 = vec3(d0s[d]);
    vec4 C = vec4(omega - darbouxSign(j) * omega0, 0) * bt_k;
    vec4 dq = (w_q / denom) * qmul(us[j + 1], C);
    vec4 du = -(w_u / denom) * qmul(us[j], C);
    us[j] += dq;
    us[j + 1] += du;
    us[j] = qnorm(us[j]);
    us[j+1] = qnorm(us[j+1]);
}

void predict(uint i) {
    // todo: hairs are only rotating about the head, but do not rotate to point in new direction
    // ? rebuilding all quaternions and Darboux vectors when headTrans is updated (serial; one thead per strand)
    if (i == getRootVertex(i)) {
        ps[i] = headTrans * hairStrands[vertexStrandMap[i]].root;
    } else {
        ps[i] = particles[i].x + particles[i].v * dt;
    }

    if (i == getTailVertex(i)) return;
    int j = toJ(int(i));
    if (j == getRootRod(j)) {
        us[j] = rods[j].q + 0.5f * qmul(rods[j].q, vec4(rods[j].v.xyz, 0)) * dt;
        us[j] = qnorm(us[j]);
    } else {
        us[j] = rods[j].q + 0.5f * qmul(rods[j].q, vec4(rods[j].v.xyz, 0)) * dt;
        us[j] = qnorm(us[j]);
    }
}

void updateVelocities(uint i) {
    particles[i].v = l_drag * (ps[i] - particles[i].x) / dt;
    particles[i].x = ps[i] * ss_SOR + particles[i].x * (1 - ss_SOR);
    ps[i] = particles[i].x;

    if (i == getTailVertex(i)) return;
    int j = toJ(int(i));
    us[j] = qnorm(us[j]);
    vec3 nv = a_drag * Im((2.f * qmul(conjugate(rods[j].q), us[j])) / dt);
    rods[j].v = vec4(nv, 0);
    // todo: this allows for more hair styles but produces undesirable results if moving too quickly
    // rods[j].q = qnorm(us[j] * (bt_SOR/2) + rods[j].q * (1 - (bt_SOR/2)));
}

// void main() {
//     uint gid = gl_GlobalInvocationID.x;
//     if (gid >= particles.length()) return;
//     int i = int(gid);
//     if (stage == STRETCH_SHEAR_CONSTRAINT || stage == BEND_TWIST_CONSTRAINT) {
//         if (rbgs == 0) i = i * 2; // red: even
//         else if (rbgs == 1) i = i * 2 + 1; // black: odd
//     }
//     if (i >= particles.length()) return;
//     int idx = i;
    
//     switch (stage) {
//         case APPLY_EXTERNAL_FORCES:
//             applyExternalForces(idx);
//             break;
//         case PREDICT:
//             predict(idx);
//             break;
//         case RESOLVE_COLLISIONS:
//             resolveCollisions(idx);
//             break;
//         case STRETCH_SHEAR_CONSTRAINT:
//             stretchAndShearConstraint(idx);
//             break;
//         case BEND_TWIST_CONSTRAINT:
//             bendAndTwistConstraint(idx);
//             break;
//         case UPDATE_VELOCITIES:
//             updateVelocities(idx);
//             break;
//         default:
//             return;
//     };
// }
